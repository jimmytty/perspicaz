#+BLOG: perspicaz
#+POSTID: 655
#+DATE: [2021-08-09 Mon 15:50]
#+OPTIONS: toc:nil num:nil todo:nil pri:nil tags:nil ^:nil ^:{}
#+PARENT:
#+CATEGORY: Uncategorized
#+TAGS:
#+DESCRIPTION:
#+TITLE: Criando arquivos com nomes sequenciais usando letras ao inv√©s de n√∫meros
#+PERMALINK: criando-arquivos-com-nomes-sequenciais-usando-letras-ao-inves-de-numeros

Criar arquivos sequencias usando n√∫meros como por exemplo:

: arq-01.txt
: arq-02.txt
: arq-03.txt

s√£o coisas muito simples e muito √∫teis tamb√©m. Na dica de hoje vou abordar a mesma tarefa incrementando letras ao inv√©s de n√∫meros. Pode ser √∫til em alguns casos, mas com certeza √© um √≥timo exerc√≠cio! üòÅ

#+HTML: <!--more Continue lendo...-->

Para simplificar, vou considerar apenas o intervalo "a-z" e duas posi√ß√µes como no exemplo citado, tornando poss√≠vel criar at√© =626= arquivos (26 * 26).

Pretendo abordar duas formas distintas e incrementar letras:

** Abordagem 1
Utilizando a tabela ascii como refer√™ncia (=man 7 ascii=).
   Onde voc√™ pode conferir que os intervalos num√©ricos s√£o:
     * Bin√°rio n√£o consta na p√°gina de manual da tabela ascii mas seria o caso fazer uma convers√£o num√©rica.
     | Nota√ß√£o     |  In√≠cio |     Fim |
     |-------------+---------+---------|
     | Octal       |     141 |     172 |
     | Decimal     |      97 |     122 |
     | Hexadecimal |      61 |      7A |
     | Bin√°rio     | 1100001 | 1111010 |

   A implementa√ß√£o neste caso √© basicamente escolher a nota√ß√£o mais conveniente na linguagem/ferramenta escolhida e utilizar o m√©todo para transformar n√∫mero em letra.

** Abordagem 2
Criando uma lista com intervalo de "/a"/ a "/z/" e usando a posi√ß√£o delas como refer√™ncia.
   Exemplo:
   | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | ... | 26 |
   |---+---+---+---+---+---+---+---+---+-----+----|
   | a | b | c | d | e | f | g | h | i | ... |  z |

   Ou seja, cada posi√ß√£o da lista corresponde a uma letra.

   Ou seja, criar uma lista e iterar pelo seu √≠ndice para obter a letra. Neste exemplo o /array/ √© inicializado em 1 mas pode ser o 0 dependendo da linguagem/ferramenta utilizada.

Vamos para √†s solu√ß√µes:

** Shell

Obs.: Assumindo apenas solu√ß√µes mais port√°veis entre os v√°rios /shells/ existentes. Testadas no ~ash~ (vers√£o atual mais pr√≥xima do ~sh~ original).

*** [[Abordagem 1]]
a) Usando ~bc~ para transformar o intervalo decimal gerado pelo ~seq~ em nota√ß√£o octal e acertando a sintaxe para o ~prinft~ conseguir converter:
  #+BEGIN_SRC sh
    seq=$(seq 97 122)
    for dec1 in $seq; do
        oct1=$(echo 'ibase=A;obase=8;'$dec1|bc)
        oct1="\\"$oct1
        for dec2 in $seq; do
              oct2=$(echo 'ibase=A;obase=8;'$dec2|bc)
              oct2="\\"$oct2
              filename=$(printf 'arq-%b%b.txt\n' "$oct1" "$oct2")
              touch $filename
        done
    done
  #+END_SRC

b) Usando ~awk~ (que poderia ter sido no exemplo "a)" tamb√©m) para criar os /filenames/. Como ~awk~ n√£o cria arquivos, recorro ao ~shell~ para concluir o servi√ßo:
  #+BEGIN_SRC awk
    awk 'BEGIN {
        for ( i = 97; i <= 122; i++ ) {
            for ( j = 97; j <= 122; j++ ) {
                printf "arq-%c%c.txt\n", i, j;
            }
        }
    }' | xargs touch
  #+END_SRC

c) Uma forma ex√≥tica usando a calculadora ~dc~ (pertence ao pacote padr√£o da ~bc~):
    #+BEGIN_SRC sh
    seq=$(seq 97 122)
    for dec1 in $seq; do
        l1=$(echo "${dec1}P"|dc)
        for dec2 in $seq; do
            l2=$(echo "${dec2}P"|dc)
            filename="arq-$l1$l2.txt"
            touch $filename
        done
    done
    #+END_SRC

    A m√°gica aqui √© feita pelo par√¢metro "~P~" que instrui √† ~dc~ converter o n√∫mero decimal para o seu corresponde ~ascii~ (a documenta√ß√£o n√£o √© muito clara sobre essa convers√£o).
*** [[Abordagem 2]]

a) O ~sh~ padr√£o n√£o possui estruturas de dados como /array/, ent√£o precisamos simular um com /string/:

  #+BEGIN_SRC sh
    chars='abcdefghijklmnopqrstuvwxyz'
    seq=$(seq 1 26)

    for dec1 in $seq; do
        char1=$(echo $chars | cut -c $dec1)
        for dec2 in $seq; do
            char2=$(echo $chars | cut -c $dec2)
            filename="arq-${char1}${char2}.txt"
            touch $filename
        done
    done
  #+END_SRC

b) Para usar /arrays/ num /shell/ padr√£o precisamos recorrer a, por exemplo, ~awk~:

  #+BEGIN_SRC awk
    awk 'BEGIN {
        n=split("abcdefghijklmnopqrstuvwxyz", chars, //);
        for ( i = 1; i <= n; i++ ) {
            for ( j = 1; j <= n; j++ ) {
                printf "arq-%s%s.txt\n", chars[i], chars[j];
            }
        }
    }' | xargs touch
  #+END_SRC

c) Usando o ~sed~ para criar uma lista de letras:
   #+BEGIN_SRC sh
     chars='abcdefghijklmnopqrstuvwxyz'
     for c1 in $(echo $chars | sed 's/\B/ /g'); do
         for c2 in $(echo $chars | sed 's/\B/ /g'); do
             filename="arq-${c1}${c2}.txt"
             echo touch $filename
         done
     done
   #+END_SRC

** Perl

Obs: Existem bibliotecas externas que simplificam a solu√ß√£o para apenas uma linha n√£o ser√£o usadas nesse exerc√≠cio.

*** [[Abordagem 1]]

a) Criando os /loops/ e usando a fun√ß√£o ~chr~ para converter n√∫mero para letra:

   #+BEGIN_SRC perl
     for ( my $i = 97; $i <= 122; $i++ ) {
         my $char1 = chr $i;
         for ( my $j = 97; $j <= 122; $j++ ) {
             my $char2 = chr $j;
             my $filename = 'arq-' . $char1 . $char2 . '.txt';
             open my $fh, '>', $filename;
         }
     }
   #+END_SRC

b) Utilizando o comando ~pack~ e um estildo diferente de /loop/ em rela√ß√£o ao exerc√≠cio "a)":

   #+BEGIN_SRC perl
     my @range = 97 .. 122;
     for my $i ( @range ) {
         my $char1 = pack 'C', $i;
         for my $j ( @range )  {
             my $char2 = pack 'C', $j;
             my $filename = "arq-${char1}${char2}.txt";
             IO::File->new($filename,'w');
         }
     }
   #+END_SRC

c) Utilizando o comando ~sprintf~ e permuta√ß√£o com o ~glob~:

   #+BEGIN_SRC perl
     use File::Copy qw[cp];
     my @range = 97 .. 122;
     my @permute = glob sprintf '{%s}{x}{%s}', map {join ',', @range} 1..2;
     foreach my $permute ( @permute ) {
         my @char = split /x/, $permute;
         my $filename = sprintf 'arq-%c%c.txt', @char;
         cp '/dev/null', $filename;
     }
   #+END_SRC

*** [[Abordagem 2]]
a)
   #+BEGIN_SRC
    
